<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale JS Simulation (Final)</title>
    <style>
        /* Base Styling */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #1E293B, #0F172A);
            padding: 16px;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Info Bar */
        .info-bar {
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .info-item {
            padding: 8px 16px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            color: white;
            white-space: nowrap;
        }

        .elixir-bar {
            background-color: #7C3AED;
        }

        .time-display {
            background-color: #334155;
            transition: all 0.3s ease;
        }

        .overtime {
            background-color: #DC2626;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from {
                opacity: 1;
            }
            to {
                opacity: 0.7;
            }
        }

        /* Game Area and Canvas */
        .game-area {
            position: relative;
            width: 600px;
            height: 900px;
        }

        #game-canvas {
            border: 4px solid #D97706;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.4);
            cursor: crosshair;
            display: block;
        }

        /* Hand Container (Card Models) */
        .hand-container {
            margin-top: 16px;
            display: flex;
            gap: 12px;
        }

        .card-button {
            position: relative;
            padding: 16px;
            border-radius: 8px;
            border: 2px solid #475569;
            background: linear-gradient(to bottom, #334155, #1E293B);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            /* CRUCIAL: Ensure buttons are visually above the canvas container's siblings */
            z-index: 10; 
        }

        .card-button:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .card-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #0F172A;
        }

        .card-selected {
            border-color: #FBBF24 !important;
            transform: scale(1.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        .card-cost {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #7C3AED;
            color: white;
            border-radius: 9999px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            /* CRUCIAL: Ensure cost bubble is on top */
            z-index: 12;
        }

        .card-icon {
            width: 32px;
            height: 32px;
            margin-bottom: 4px;
        }

        /* Game Over Button Overlay */
        .game-over-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20; /* Ensures it is above the canvas */
            background-color: #10B981;
            color: white;
            font-weight: bold;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 18px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .game-over-button:hover {
            background-color: #059669;
        }

        .game-messages {
            margin-top: 16px;
            text-align: center;
            color: #94A3B8;
            font-size: 14px;
            max-width: 448px;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="info-bar" id="info-bar">
            </div>

        <div class="game-area">
            <canvas id="game-canvas" width="600" height="900"></canvas>
            <button id="reset-button" class="game-over-button" style="display: none;">
                Play Again
            </button>
        </div>

        <div class="hand-container" id="hand-container">
            </div>

        <div class="game-messages">
            <p>Click a card, then click behind your bridge to deploy! (Log can be deployed anywhere)</p>
            <p>Side towers have priority - destroy them first! Max 4 of each unit.</p>
        </div>
    </div>

    <script>
        // --- Icon Placeholder Components ---
        const IconTemplates = {
            Sword: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="card-icon"><path d="M20 6L9 17L18 20L21 16L12 7L20 6Z"/><path d="M12 7L16 11L9 18L5 14L12 7Z"/><path d="M16 3L19 6L21 4L18 1Z"/></svg>`,
            Shield: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="card-icon"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>`,
            Zap: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="card-icon"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>`,
            Crown: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="card-icon"><path d="M12 5l-2 3H4l3-4 5-2 5 2 3 4h-6l-2-3z"/><path d="M5 21l-1-10 8-5 8 5-1 10"/></svg>`,
            Wind: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="card-icon"><path d="M17.5 10A7.5 7.5 0 0 0 13 3c-1.2 0-2.4.4-3.4 1.2-1.2.9-1.9 2.2-2.1 3.6"/><path d="M20 7h-2"/><path d="M19 14h-6"/><path d="M15 21h-2"/><path d="M12 14v4a4 4 0 0 1-8 0v-4a4 4 0 0 1 8 0z"/></svg>`,
        };

        // --- Constants and Initial Setup ---
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 900;
        const ELIXIR_MAX = 10;
        const BRIDGE_Y = 450;
        const LEFT_BRIDGE_START = 100;
        const LEFT_BRIDGE_END = 200;
        const RIGHT_BRIDGE_START = 400;
        const RIGHT_BRIDGE_END = 500;

        const allCards = [
            { id: 1, name: 'Knight', cost: 3, hp: 150, damage: 20, speed: 1.0, range: 30, icon: 'Shield', color: '#8B4513', type: 'melee', targetPriority: 'units', isAerial: false },
            { id: 2, name: 'Archer', cost: 3, hp: 80, damage: 15, speed: 1.2, range: 150, icon: 'Sword', color: '#9370DB', type: 'ranged', keepDistance: 120, isAerial: false },
            { id: 3, name: 'Giant', cost: 5, hp: 500, damage: 35, speed: 0.6, range: 30, icon: 'Shield', color: '#FF6347', type: 'tank', targetPriority: 'buildings', isAerial: false },
            { id: 4, name: 'Wizard', cost: 5, hp: 150, damage: 40, speed: 1.0, range: 200, icon: 'Zap', color: '#4169E1', type: 'ranged', keepDistance: 150, isAerial: false },
            { id: 5, name: 'Dragon', cost: 4, hp: 200, damage: 25, speed: 1.5, range: 50, icon: 'Wind', color: '#FF4500', type: 'ranged', isAerial: true },
            { id: 6, name: 'HogRider', cost: 4, hp: 180, damage: 22, speed: 2.0, range: 30, icon: 'Sword', color: '#D2691E', type: 'melee', targetPriority: 'buildings', isAerial: false },
            { id: 7, name: 'SkeletonArmy', cost: 3, hp: 20, damage: 10, speed: 1.5, range: 25, icon: 'Shield', color: '#F0E68C', type: 'melee', count: 5, isAerial: false },
            { id: 8, name: 'Balloon', cost: 5, hp: 250, damage: 30, speed: 0.8, range: 180, icon: 'Wind', color: '#87CEEB', type: 'ranged', keepDistance: 120, isAerial: true, dropsSkeleton: true },
            { id: 9, name: 'MegaKnight', cost: 7, hp: 450, damage: 45, speed: 1.2, range: 35, icon: 'Shield', color: '#2C3E50', type: 'melee', targetPriority: 'units', isAerial: false, splash: true },
            { id: 10, name: 'MiniPEKKA', cost: 4, hp: 220, damage: 50, speed: 1.3, range: 30, icon: 'Sword', color: '#34495E', type: 'melee', targetPriority: 'units', isAerial: false },
            { id: 11, name: 'Log', cost: 2, hp: 9999, damage: 35, speed: 4, range: 30, icon: 'Shield', color: '#8B4513', type: 'spell', isAerial: false, lifetime: 1500 },
        ];

        let state = {}; 
        let gameInterval, elixirInterval, timerInterval;

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const handContainer = document.getElementById('hand-container');
        const infoBar = document.getElementById('info-bar');
        const resetButton = document.getElementById('reset-button');

        // --- State Management ---
        function setState(newState) {
            Object.assign(state, newState);
            renderUI();
            if (ctx) drawCanvas();
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function checkWinCondition() {
             if (state.towers.playerKing.hp <= 0 && !state.gameOver) {
                setState({ gameOver: true, winner: 'enemy' });
            }
            if (state.towers.enemyKing.hp <= 0 && !state.gameOver) {
                setState({ gameOver: true, winner: 'player' });
            }

            const playerTowersDestroyed = (state.towers.playerLeft.destroyed ? 1 : 0) + (state.towers.playerRight.destroyed ? 1 : 0);
            const enemyTowersDestroyed = (state.towers.enemyLeft.destroyed ? 1 : 0) + (state.towers.enemyRight.destroyed ? 1 : 0);

            if (playerTowersDestroyed === 2 && !state.towers.playerKing.activated) {
                state.towers.playerKing.activated = true;
            }
            if (enemyTowersDestroyed === 2 && !state.towers.enemyKing.activated) {
                state.towers.enemyKing.activated = true;
            }

            if (playerTowersDestroyed > 0 || enemyTowersDestroyed > 0) {
                if (state.elixirRate > 1000) {
                    clearInterval(elixirInterval);
                    elixirInterval = setInterval(() => {
                        setState({ 
                            elixir: Math.min(state.elixir + 1, ELIXIR_MAX), 
                            enemyElixir: Math.min(state.enemyElixir + 1, ELIXIR_MAX) 
                        });
                    }, 1000); 
                    setState({ elixirRate: 1000 });
                }
            }
        }

        function endGameByDamage() {
             const playerDamage = (state.towers.playerLeft.maxHP - state.towers.playerLeft.hp) + 
                         (state.towers.playerRight.maxHP - state.towers.playerRight.hp) + 
                         (state.towers.playerKing.maxHP - state.towers.playerKing.hp);
    
            const enemyDamage = (state.towers.enemyLeft.maxHP - state.towers.enemyLeft.hp) + 
                                (state.towers.enemyRight.maxHP - state.towers.enemyRight.hp) + 
                                (state.towers.enemyKing.maxHP - state.towers.enemyKing.hp);
            
            let winner = 'draw';
            if (enemyDamage > playerDamage) {
                winner = 'player';
            } else if (playerDamage > enemyDamage) {
                winner = 'enemy';
            }

            setState({ gameOver: true, winner });
        }

        // --- Rendering Functions ---

        function drawCanvas() {
            if (!canvas || !ctx) return;

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Battlefield
            ctx.fillStyle = '#2d5016'; // Grass
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.fillStyle = '#4A90E2'; // Water
            ctx.fillRect(0, BRIDGE_Y - 50, CANVAS_WIDTH, 100);
            
            ctx.fillStyle = '#8B4513'; // Bridges
            ctx.fillRect(LEFT_BRIDGE_START, BRIDGE_Y - 30, LEFT_BRIDGE_END - LEFT_BRIDGE_START, 60);
            ctx.fillRect(RIGHT_BRIDGE_START, BRIDGE_Y - 30, RIGHT_BRIDGE_END - RIGHT_BRIDGE_START, 60);

            // 2. Draw Towers
            const drawTower = (tower, color, isKing) => {
                const { x, y, hp, maxHP, destroyed } = tower;
                
                if (hp > 0) {
                    ctx.fillStyle = color;
                    if (isKing) {
                        ctx.fillRect(x - 40, y - 60, 80, 80);
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(x - 45, y - 40, 90, 10);
                    } else {
                        ctx.fillRect(x - 30, y - 50, 60, 70);
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(x - 35, y - 30, 70, 5);
                    }

                    // HP bar
                    ctx.fillStyle = '#000';
                    ctx.fillRect(x - 35, y - 20, 70, 10);
                    ctx.fillStyle = '#FF0000';
                    const hpPercent = hp / maxHP;
                    ctx.fillRect(x - 34, y - 19, 68 * hpPercent, 8);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x - 35, y - 20, 70, 10);
                } else if (destroyed) {
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(x - 20, y, 40, 20);
                    
                    const time = Date.now();
                    ctx.fillStyle = `rgba(255, 100, 0, ${0.6 + Math.sin(time / 180) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y - 10, 15 + Math.sin(time / 200) * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            };

            drawTower(state.towers.enemyLeft, '#ff4444', false);
            drawTower(state.towers.enemyRight, '#ff4444', false);
            drawTower(state.towers.enemyKing, '#cc0000', true);
            drawTower(state.towers.playerLeft, '#4444ff', false);
            drawTower(state.towers.playerRight, '#4444ff', false);
            drawTower(state.towers.playerKing, '#0000cc', true);

            // 3. Draw Units/Models
            const drawUnitModel = (unit) => {
                const baseY = unit.isAerial ? unit.y - 15 : unit.y;
                const isEnemy = unit.team === 'enemy';
                
                ctx.fillStyle = unit.color;
                ctx.beginPath();
                ctx.arc(unit.x, baseY, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = isEnemy ? '#FF0000' : '#0000FF';
                ctx.beginPath();
                ctx.arc(unit.x, baseY, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(unit.name[0], unit.x, baseY + 3);

                // HP bar
                ctx.fillStyle = '#000';
                ctx.fillRect(unit.x - 15, unit.y - 25, 30, 4);
                ctx.fillStyle = isEnemy ? '#FF0000' : '#00FF00';
                ctx.fillRect(unit.x - 15, unit.y - 25, 30 * (unit.hp / unit.maxHP), 4);
            };

            state.units.forEach(unit => {
                if (unit.hp > 0) {
                    if (unit.isAerial) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(unit.x, unit.y + 20, 15, 7, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    drawUnitModel(unit);
                }
            });

            // 4. Draw Projectiles
            state.projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // 5. Draw Clash Effects
            state.clashEffects.forEach(effect => {
                const age = Date.now() - effect.time;
                const opacity = 1 - (age / 300);
                const size = 10 + (age / 300) * 10;
                
                ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                ctx.stroke();
            });

            // 6. Draw Game Over Overlay
            if (state.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = state.winner === 'player' ? '#FFD700' : (state.winner === 'enemy' ? '#FF0000' : '#FFFFFF');
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(state.winner === 'player' ? 'VICTORY!' : (state.winner === 'enemy' ? 'DEFEAT!' : 'DRAW!'), CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }
        }

        function renderUI() {
            if (!infoBar || !handContainer || !resetButton) return;

            // Info Bar Update
            const timeDisplayClass = state.isOvertime ? 'time-display overtime' : 'time-display';
            const timeValue = state.isOvertime ? state.overtimeTime : state.gameTime;
            const minutes = Math.floor(timeValue / 60);
            const seconds = (timeValue % 60).toString().padStart(2, '0');

            infoBar.innerHTML = `
                <div class="info-item elixir-bar">
                    ${IconTemplates.Crown.replace('currentColor', 'yellow')}
                    <span class="text-white font-bold">Elixir: ${state.elixir}/${ELIXIR_MAX}</span>
                    ${state.elixirRate === 1000 ? '<span style="color: #FBBF24; font-size: 10px;">x2</span>' : ''}
                </div>
                <div class="${timeDisplayClass}">
                    ${state.isOvertime ? 'OVERTIME!' : 'Time'}: ${minutes}:${seconds}
                </div>
                <div class="info-item" style="background-color: #334155;">
                    <span class="text-white font-bold">Enemy King: ${Math.max(0, state.towers.enemyKing.hp)}</span>
                </div>
            `;

            // Hand Container Update
            handContainer.innerHTML = '';
            state.hand.forEach((card) => {
                const canAfford = state.elixir >= card.cost;
                const unitCount = state.units.filter(u => u.team === 'player' && u.name === card.name).length;
                const atLimit = unitCount >= 4 && card.type !== 'spell';
                
                const button = document.createElement('button');
                button.className = `card-button ${state.selectedCard?.id === card.id ? 'card-selected' : ''}`;
                button.disabled = !canAfford || atLimit;
                button.innerHTML = `
                    ${IconTemplates[card.icon].replace('currentColor', card.color)}
                    <div style="font-size: 12px; font-weight: bold;">${card.name}</div>
                    ${atLimit ? '<div style="color: #F87171; font-size: 12px;">MAX</div>' : ''}
                    <div class="card-cost">${card.cost}</div>
                `;

                button.onclick = () => {
                    if (!button.disabled) {
                        setState({ selectedCard: card });
                    }
                };
                
                handContainer.appendChild(button);
            });

            // Reset Button Update
            if (state.gameOver) {
                resetButton.style.display = 'block';
            } else {
                resetButton.style.display = 'none';
            }
        }

        // --- Game Logic ---

        function deployUnit(card, x, y, team) {
            if (card.name === 'SkeletonArmy') {
                const newSkeletons = [];
                for (let i = 0; i < card.count; i++) {
                    const offsetX = (Math.random() - 0.5) * 60;
                    const offsetY = (Math.random() - 0.5) * 60;
                    newSkeletons.push({
                        id: Date.now() + Math.random() + i, name: 'Skeleton',
                        x: x + offsetX, y: y + offsetY, hp: card.hp, maxHP: card.hp,
                        damage: card.damage, speed: card.speed, range: card.range,
                        team, lastAttack: 0, type: card.type, isAerial: card.isAerial, color: card.color,
                    });
                }
                setState({ units: [...state.units, ...newSkeletons] });
            } else if (card.name === 'Log') {
                const newUnit = {
                    id: Date.now() + Math.random(), name: card.name, x, y,
                    hp: card.hp, maxHP: card.hp, damage: card.damage, speed: card.speed, range: card.range,
                    team, lastAttack: 0, type: card.type, isAerial: card.isAerial, color: card.color,
                    lifetime: card.lifetime, spawnTime: Date.now(),
                };
                setState({ units: [...state.units, newUnit] });
            } else {
                const newUnit = {
                    id: Date.now() + Math.random(), name: card.name, x, y, hp: card.hp, maxHP: card.hp,
                    damage: card.damage, speed: card.speed, range: card.range, team, lastAttack: 0,
                    type: card.type, targetPriority: card.targetPriority, keepDistance: card.keepDistance,
                    isAerial: card.isAerial, color: card.color, dropsSkeleton: card.dropsSkeleton,
                    splash: card.splash,
                };
                setState({ units: [...state.units, newUnit] });
            }
        }

        function handleCanvasClick(e) {
            if (!state.selectedCard || state.gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const isValidPlayerDeploy = y > BRIDGE_Y + 20 && y < 760;
            const canDeploySpell = state.selectedCard.type === 'spell';

            if ((isValidPlayerDeploy || canDeploySpell) && state.elixir >= state.selectedCard.cost) {
                const unitCount = state.units.filter(u => u.team === 'player' && u.name === state.selectedCard.name).length;
                
                if (unitCount >= 4 && state.selectedCard.type !== 'spell') {
                    return;
                }

                deployUnit(state.selectedCard, x, y, 'player');
                
                // Card Cycle Logic
                const usedCard = state.selectedCard;
                let newHand = [...state.hand];
                let newDeck = [...state.deck];
                const cardIndex = newHand.findIndex(c => c.id === usedCard.id);

                if (cardIndex !== -1) {
                    const availableCards = state.deck.filter(c => !newHand.some(h => h.id === c.id));
                    
                    if (availableCards.length > 0) {
                        const newCard = availableCards[Math.floor(Math.random() * availableCards.length)]; 
                        newHand[cardIndex] = newCard;
                        
                        newDeck = newDeck.filter(c => c.id !== newCard.id);
                        newDeck.push(usedCard);
                    }
                }
                
                setState({ 
                    elixir: state.elixir - usedCard.cost, 
                    selectedCard: null,
                    hand: newHand,
                    deck: newDeck
                });
            }
        }

        function resetGame() {
            stopGameLoops(); 

            state = {
                elixir: 5,
                enemyElixir: 5,
                elixirRate: 2000,
                units: [],
                projectiles: [],
                towerArchers: [
                    { id: 'pl', towerId: 'playerLeft', x: 100, y: 665, team: 'player', lastShot: 0 },
                    { id: 'pr', towerId: 'playerRight', x: 500, y: 665, team: 'player', lastShot: 0 },
                    { id: 'el', towerId: 'enemyLeft', x: 100, y: 125, team: 'enemy', lastShot: 0 },
                    { id: 'er', towerId: 'enemyRight', x: 500, y: 125, team: 'enemy', lastShot: 0 },
                ],
                clashEffects: [],
                selectedCard: null,
                gameOver: false,
                winner: null,
                gameTime: 90,
                isOvertime: false,
                overtimeTime: 180,
                towers: {
                    playerLeft: { x: 100, y: 720, hp: 2500, maxHP: 2500, destroyed: false },
                    playerRight: { x: 500, y: 720, hp: 2500, maxHP: 2500, destroyed: false },
                    playerKing: { x: 300, y: 820, hp: 4000, maxHP: 4000, activated: false },
                    enemyLeft: { x: 100, y: 180, hp: 2500, maxHP: 2500, destroyed: false },
                    enemyRight: { x: 500, y: 180, hp: 2500, maxHP: 2500, destroyed: false },
                    enemyKing: { x: 300, y: 80, hp: 4000, maxHP: 4000, activated: false },
                },
            };

            const shuffled = [...allCards];
            shuffle(shuffled);
            state.deck = shuffled.slice(4);
            state.hand = shuffled.slice(0, 4);

            startGameLoops();
            renderUI();
            drawCanvas();
        }

        function startGameLoops() {
            elixirInterval = setInterval(() => {
                setState({ 
                    elixir: Math.min(state.elixir + 1, ELIXIR_MAX), 
                    enemyElixir: Math.min(state.enemyElixir + 1, ELIXIR_MAX) 
                });
            }, state.elixirRate);

            timerInterval = setInterval(() => {
                if (state.gameOver) return stopGameLoops();

                if (!state.isOvertime) {
                    if (state.gameTime > 0) {
                        setState({ gameTime: state.gameTime - 1 });
                    } else {
                        setState({ isOvertime: true });
                        if (state.elixirRate > 1000) {
                           clearInterval(elixirInterval);
                           elixirInterval = setInterval(() => {
                                setState({ 
                                    elixir: Math.min(state.elixir + 1, ELIXIR_MAX), 
                                    enemyElixir: Math.min(state.enemyElixir + 1, ELIXIR_MAX) 
                                });
                            }, 1000);
                           setState({ elixirRate: 1000 });
                        }
                    }
                } else if (state.overtimeTime > 0) {
                    setState({ overtimeTime: state.overtimeTime - 1 });
                } else {
                    endGameByDamage();
                    stopGameLoops();
                }
            }, 1000);

            gameInterval = setInterval(gameTick, 50);
        }

        function stopGameLoops() {
            clearInterval(elixirInterval);
            clearInterval(timerInterval);
            clearInterval(gameInterval);
            gameInterval = null;
        }

        function gameTick() {
            if (state.gameOver) return stopGameLoops();

            let newProjectiles = [...state.projectiles];
            let newTowerArchers = state.towerArchers.map(archer => {
                const tower = state.towers[archer.towerId];
                if (!tower || tower.hp <= 0) return archer;
                
                let nearestEnemy = null;
                let minDist = Infinity;
                
                state.units.forEach(unit => {
                    if (unit.team !== archer.team && unit.hp > 0) {
                        const dist = Math.hypot(unit.x - archer.x, unit.y - archer.y);
                        if (dist < 250 && dist < minDist) { 
                            minDist = dist;
                            nearestEnemy = unit;
                        }
                    }
                });
                
                const isKingTower = archer.towerId.includes('King');
                if (isKingTower && !state.towers[archer.towerId].activated) {
                } else if (nearestEnemy && (!archer.lastShot || Date.now() - archer.lastShot > 1500)) {
                    newProjectiles.push({
                        id: Date.now() + Math.random(), x: archer.x, y: archer.y,
                        targetX: nearestEnemy.x, targetY: nearestEnemy.y, target: nearestEnemy,
                        damage: 15, speed: 5, color: '#9370DB', isTowerArcher: true,
                    });
                    return { ...archer, lastShot: Date.now() };
                }
                return archer;
            });

            let newUnits = [];
            let newClashEffects = [...state.clashEffects];
            
            state.units.forEach(unit => {
                if (unit.hp <= 0) {
                    if (unit.dropsSkeleton) {
                        for (let i = 0; i < 2; i++) {
                            const newSkel = {
                                id: Date.now() + Math.random() * i, name: 'Skeleton',
                                x: unit.x + (Math.random() - 0.5) * 40, y: unit.y,
                                hp: 20, maxHP: 20, damage: 10, speed: 1.5, range: 25,
                                team: unit.team, lastAttack: 0, type: 'melee', isAerial: false, color: '#F0E68C',
                            };
                            newUnits.push(newSkel);
                        }
                    }
                    return;
                }

                if (unit.name === 'Log') {
                    if (!unit.spawnTime) unit.spawnTime = Date.now();
                    if (Date.now() - unit.spawnTime > unit.lifetime) return;
                    
                    const direction = unit.team === 'player' ? -1 : 1;
                    unit.y += unit.speed * direction;
                    
                    state.units.filter(o => o.team !== unit.team && o.hp > 0 && !o.isAerial).forEach(other => {
                        const dist = Math.hypot(unit.x - other.x, unit.y - other.y);
                        if (dist < 40 && !other.hitByLog) {
                            other.hp -= unit.damage;
                            other.hitByLog = true;
                            const pushDirection = unit.team === 'player' ? -1 : 1;
                            other.y += pushDirection * 20; 
                            setTimeout(() => delete other.hitByLog, 100);
                            newClashEffects.push({ id: Date.now() + Math.random(), x: other.x, y: other.y, time: Date.now() });
                        }
                    });
                    newUnits.push(unit);
                    return;
                }

                const enemyUnits = [];
                const enemyTowers = [];
                const opponentTowers = unit.team === 'player' ? ['enemyLeft', 'enemyRight', 'enemyKing'] : ['playerLeft', 'playerRight', 'playerKing'];

                opponentTowers.forEach(key => {
                    const tower = state.towers[key];
                    if (tower.hp > 0) {
                        const dist = Math.hypot(unit.x - tower.x, unit.y - tower.y);
                        enemyTowers.push({ target: tower, dist, type: 'tower', key });
                    }
                });

                state.units.forEach(other => {
                    if (other.team !== unit.team && other.hp > 0) {
                        if (!unit.isAerial && other.isAerial && unit.type === 'melee') return;
                        const dist = Math.hypot(unit.x - other.x, unit.y - other.y);
                        enemyUnits.push({ target: other, dist, type: 'unit' });
                    }
                });

                let target = null;
                let minDist = Infinity;

                const allTargets = [...enemyUnits, ...enemyTowers].sort((a, b) => a.dist - b.dist);

                if (unit.targetPriority === 'buildings') {
                    enemyTowers.sort((a, b) => a.dist - b.dist);
                    if (enemyTowers.length > 0) {
                        target = enemyTowers[0].target;
                        minDist = enemyTowers[0].dist;
                    } else if (allTargets.length > 0) {
                        target = allTargets[0].target;
                        minDist = allTargets[0].dist;
                    }
                } else {
                    if (allTargets.length > 0) {
                        target = allTargets[0].target;
                        minDist = allTargets[0].dist;
                    }
                }

                if (target) {
                    if (minDist < unit.range) {
                        if (!unit.lastAttack || Date.now() - unit.lastAttack > 1000) {
                            const damageAmount = unit.isAerial && target.hp !== undefined ? unit.damage * 0.8 : unit.damage;
                            
                            if (unit.type === 'ranged') {
                                newProjectiles.push({
                                    id: Date.now() + Math.random(), x: unit.x, y: unit.y, 
                                    targetX: target.x, targetY: target.y, target: target, 
                                    damage: damageAmount, speed: 5, color: unit.color,
                                });
                            } else if (unit.splash) {
                                allTargets.forEach(t => {
                                    const distFromUnit = Math.hypot(unit.x - t.target.x, unit.y - t.target.y);
                                    if (distFromUnit < 60) {
                                        t.target.hp -= damageAmount * (t.target === target ? 1 : 0.5);
                                        newClashEffects.push({ id: Date.now() + Math.random(), x: t.target.x, y: t.target.y, time: Date.now() });
                                    }
                                });
                            } else {
                                if (target.hp !== undefined) {
                                    target.hp -= damageAmount;
                                    newClashEffects.push({ id: Date.now() + Math.random(), x: (unit.x + target.x) / 2, y: (unit.y + target.y) / 2, time: Date.now() });
                                }
                            }
                            unit.lastAttack = Date.now();
                        }
                    } else {
                        const dx = target.x - unit.x;
                        const dy = target.y - unit.y;
                        const dist = Math.hypot(dx, dy);
                        
                        const shouldKite = unit.keepDistance && allTargets.length > 0 && allTargets[0].dist < unit.keepDistance;

                        if (shouldKite) {
                            const enemyTarget = allTargets[0].target;
                            const kiteDx = unit.x - enemyTarget.x;
                            const kiteDy = unit.y - enemyTarget.y;
                            const kiteDist = Math.hypot(kiteDx, kiteDy);
                            
                            unit.x += (kiteDx / kiteDist) * unit.speed;
                            unit.y += (kiteDy / kiteDist) * unit.speed;
                        } else {
                            const moveX = unit.x + (dx / dist) * unit.speed;
                            const moveY = unit.y + (dy / dist) * unit.speed;

                            if (unit.isAerial) {
                                unit.x = moveX;
                                unit.y = moveY;
                            } else {
                                const isInWater = moveY > BRIDGE_Y - 50 && moveY < BRIDGE_Y + 50;
                                const isOnBridge = (moveX >= LEFT_BRIDGE_START && moveX <= LEFT_BRIDGE_END) || (moveX >= RIGHT_BRIDGE_START && moveX <= RIGHT_BRIDGE_END);

                                if (!isInWater || isOnBridge) {
                                    unit.x = moveX;
                                    unit.y = moveY;
                                } else {
                                    const leftCenter = (LEFT_BRIDGE_START + LEFT_BRIDGE_END) / 2;
                                    const rightCenter = (RIGHT_BRIDGE_START + RIGHT_BRIDGE_END) / 2;
                                    const targetCenter = Math.abs(unit.x - leftCenter) < Math.abs(unit.x - rightCenter) ? leftCenter : rightCenter;
                                    
                                    const bridgeDx = targetCenter - unit.x;
                                    const bridgeDy = BRIDGE_Y - unit.y;
                                    const bridgeDist = Math.hypot(bridgeDx, bridgeDy);

                                    if (bridgeDist > 5) {
                                        unit.x += (bridgeDx / bridgeDist) * unit.speed;
                                        unit.y += (bridgeDy / bridgeDist) * unit.speed;
                                    }
                                }
                            }
                        }
                    }
                }
                newUnits.push(unit);
            });

            newProjectiles = newProjectiles.filter(proj => {
                const dx = proj.target.x - proj.x;
                const dy = proj.target.y - proj.y;
                const dist = Math.hypot(dx, dy);

                if (dist < proj.speed || proj.target.hp <= 0) {
                    if (proj.target.hp !== undefined && proj.target.hp > 0) {
                        proj.target.hp -= proj.damage;
                        
                        Object.entries(state.towers).forEach(([key, tower]) => {
                            if (tower === proj.target) {
                                if (tower.hp <= 0 && !tower.destroyed) {
                                    state.towers[key].destroyed = true;
                                    checkWinCondition();
                                }
                            }
                        });
                        
                        newClashEffects.push({ id: Date.now() + Math.random(), x: proj.target.x, y: proj.target.y, time: Date.now() });
                    }
                    return false;
                }

                proj.x += (dx / dist) * proj.speed;
                proj.y += (dy / dist) * proj.speed;
                return true;
            });

            if (state.enemyElixir >= 4 && Math.random() > 0.985) {
                const availableCards = allCards.filter(card => {
                    const count = state.units.filter(u => u.team === 'enemy' && u.name === card.name).length;
                    return count < 4 && state.enemyElixir >= card.cost && card.type !== 'spell';
                });
                
                if (availableCards.length > 0) {
                    const card = availableCards[Math.floor(Math.random() * availableCards.length)];
                    const x = Math.random() * (CANVAS_WIDTH - 100) + 50;
                    const y = Math.random() * 100 + 50;
                    
                    deployUnit(card, x, y, 'enemy');
                    state.enemyElixir -= card.cost;
                }
            }

            state.units = newUnits.filter(u => u.hp > 0);
            state.projectiles = newProjectiles;
            state.towerArchers = newTowerArchers;
            state.clashEffects = state.clashEffects.filter(e => Date.now() - e.time < 300);
            
            checkWinCondition();
            renderUI();
            drawCanvas();
        }

        // --- Initialization ---

        function init() {
            try {
                if (canvas) {
                    canvas.addEventListener('click', handleCanvasClick);
                }
                if (resetButton) {
                    resetButton.addEventListener('click', resetGame);
                }
                resetGame();
            } catch (error) {
                console.error("Initialization failed:", error);
                alert("The game failed to start. Check the console for JavaScript errors.");
            }
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
